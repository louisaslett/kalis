---
title: "Decoding a Single Locus"
author: "Louis Aslett & Ryan Christ"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Decoding a Single Locus}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In order to demonstrate how to use \pkg{kalis} to calculate and plot a local distance matrix $d^{\ell}$, the package comes with an toy dataset of 100 simulated haplotypes, \code{SmallHaps}, stored as a $L = 500$ by $N=100$ \code{matrix}. 

```{r}
require(kalis)
data("SmallHaps")
```

\pkg{kalis} maintains a special cache for loading a haplotype dataset (see next section for details).  Since \pkg{kalis} is designed for much larger datasets than this toy example that we would often never want load into \code{R}, haplotypes can be imported directly into the \pkg{kalis} cache using \code{CacheHaplotypes}.  \pkg{kalis} can only cache and operate on one haplotype dataset at a time.  Currently, \code{CacheHaplotypes} requires that the haplotypes be stored in our custom HDF5 format but support for other common formats will be added shortly.  In the following section we provide simple instructions for converting common file formats like VCFs and HAP/SAMPLE/LEGEND generated by SHAPEIT2 to our HDF5 format.  However, if the haplotypes are loaded into a \code{R} \code{matrix}, we can easily import them straight into the \pkg{kalis} cache using \code{CacheHaplotypes}.

```{r}
CacheHaplotypes(SmallHaps)
```

From \code{R} we can inspect the haplotype cache to ensure that the data has loaded correctly using \code{QueryCache}.  With the haplotypes loaded, next we must specify our model parameters.  First we supply a recombination map, $m$, where $m^\ell$ is the distance between locus $\ell$ and $\ell + 1$ in Morgans.  Here we randomly generate a recombination map and set the remaining parameters to their default values.  

```{r}
m <- rbeta(500-1,1,10)*1e-6
pars <- Parameters(CalcRho(cM = m, s = 1, gamma = 1), mu = 1e-8)
```

Next we must initialize a forward table object with our parameters that will start at locus $0$ and a backward table object that will start at the locus $L+1$.  We then use the function \code{Forward} to propagate the forward table \code{fwd} using parameters \code{pars} to target locus $250$.  We do the same with the backward table using the \code{Backward} function.  Note that \code{Forward} and \code{Backward} do not return anything, the tables \code{fwd} and \code{bck} are updated in place.

```{r}
fwd <- MakeForwardTable(pars)
bck <- MakeBackwardTable(pars)

Forward(fwd, pars, 250)
Backward(bck, pars, 250)
```

Now that \code{fwd} and \code{bck} are at the same locus, they can be combined to obtain $p^\ell$ or $d^\ell$ as follows.

```{r}

#p <- PostProbs(fwd,bck)
#M <- DistMat(fwd,bck)

```

The distance matrix can be easily clustered and visualized just by calling 

```{r, results='asis'}
#plot(M)
```

In some applications, one might want to symmetrize the matrix before plotting as follows.  
```{r, results='asis'}
#M <- 0.5*(M + t(M))
#plot(M)
```