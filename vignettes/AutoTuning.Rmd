---
title: "Auto-tuning HMM Parameters for Local Phylogeny Inference"
author: "Louis Aslett & Ryan Christ"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Auto-tuning HMM Parameters for Local Phylogeny Inference}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```
### Provide a Working Directory
```{r run.dir, eval=FALSE}
run.dir <- "~/Desktop/autotuning_test_files/"
```


```{r load.data, results = "hide", message=FALSE, eval=FALSE}
require(kalis)
require(RSpectra)
require(mlrMBO)
require(future)
require(pryr)
require(QForm)
require(plotly)
require(akima)

source("../../AutoTune2_local.R")

data("SmallHaps")
#haps <- SmallHaps[polymorphic.sites,]
CacheHaplotypes(SmallHaps)
m <- rbeta(nrow(SmallHaps)-1,1,10)*1e-6
pars <- Parameters(CalcRho(cM = m, s = 1e-250, gamma = 1), mu = 1e-250)

polymorphic.sites <- rowSums(SmallHaps)!=0 & rowSums(SmallHaps)!=1
G <- tcrossprod(scale(t(SmallHaps[polymorphic.sites,])))
bg.vecs <- RSpectra::eigs(G,10)$vectors
```



### Define Target Loci for Tuning
```{r autotuning_pars, eval=FALSE}
nthreads <- 2
num.target.loci <- 10
targets <- InvRecombMap(m,num.target.loci = num.target.loci)
```

### Set Up Optimization Using mlrMBO
```{r autotuning_targets, results="hide", eval=FALSE}


# Define Bounds on Parameters and Objective Function
ps <- makeParamSet(
  makeNumericParam("neg.log10.Ne", lower=0,upper=300),
  makeNumericParam("gamma", lower=1,upper=1),
  makeNumericParam("neg.log10.mu", lower=0,upper=300)
)


obj.fun <- makeSingleObjectiveFunction(name = "autotune", fn = AutoTuneTarget3, par.set = ps)

# Define kernel for Gaussian Process to Use
surr.km <- makeLearner("regr.bgp", predict.type = "se")#, control = list(trace = FALSE))

# Set number of steps optimizer can take after grid evaluations
control <- makeMBOControl() ;  control <- setMBOControlTermination(control, iters = 2)

# Set Initial Grid of Points at which to evaluate objective
des <- data.frame( y = c(-.2,-.6,-.2,-.6),
                   neg.log10.Ne = rep(c(0,280),each = 2),
                   gamma = rep(1,4),
                   neg.log10.mu = rep(c(0,280),2)
)

start <- proc.time()
res = mbo(fun=obj.fun, design=des, learner = surr.km, control = control,
          more.args = list(morgan.dist = m, t = targets, bg.vecs = bg.vecs, nthreads = 2, k = 5, run.dir = run.dir))
finish <- proc.time() -start
#
optimal.pars <- res$opt.path$env$path[res$best.ind,]
print(res)
print(finish)
###


```


### Plot Autotuning Results

```{r plot.autotune, eval = F, echo = F, results='asis', eval=FALSE}
PlotAutotuneSurf(x = res$opt.path$env$path$neg.log10.Ne,
                 y = res$opt.path$env$path$neg.log10.mu, 
                 z = - res$opt.path$env$path$y, 
                 xlab = "-log10Ne", ylab = "-log10mu")
```




