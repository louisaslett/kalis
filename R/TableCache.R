#' Title
#'
#' Short description
#'
#' Detailed description
#'
#' @param size the maximum amount of RAM (in GB) to devote to this cache.
#' @param from_recipient ...
#' @param to_recipient ...
#'
#' @return Return value
#'
#' @seealso See also
#'
#' @examples
#' # Examples
CreateForwardTableCache <- function(pars, size = 1, from_recipient = 1, to_recipient = Inf, max.tables = 0) {
  if(!("kalisParameters" %in% class(pars))) {
    stop("The pars argument is not a valid parameters object.")
  }

  haps <- get("haps", envir = pkgCache)
  if(anyNA(haps)) {
    stop("No haplotypes cached ... cannot determine table size until cache is loaded with CacheAllHaplotypes().")
  }
  N <- length(haps)
  L <- get("hap_size", envir = pkgCache)

  if(from_recipient>to_recipient) {
    stop("from_recipient must be smaller than to_recipient.")
  }
  if(from_recipient < 1) {
    from_recipient <- 1
  }
  if(to_recipient > N) {
    to_recipient <- N
  }
  delN <- to_recipient-from_recipient+1
  if(!is.vector(max.tables) || !is.numeric(max.tables) || length(max.tables) != 1 || max.tables < 0) {
    stop("max.tables must be a positive scalar.")
  }

  cat("Found", N, "haplotypes in the cache.")
  if((delN*N+2*delN+1)*8/1e9 > size) {
    stop(size, "GB is not big enough for even 1 table.")
  }
  cat("  Constructing table cache of appropriate size ...\n")

  if(max.tables == 0) {
    max.tables <- floor(log2(L))
  }
  cache <- list()
  i <- 1
  while((length(cache) == 0 || ((object.size(cache)*(length(cache)+1))/length(cache))/1e9 < size) && length(cache)<max.tables) {
    cache[[i]] <- MakeForwardTable(pars, from_recipient, to_recipient)
    i <- i+1
  }
  cat("Cache constructed, can hold ", length(cache), " tables for recipients ", from_recipient, " ... ", to_recipient, ".  Actual size ≈ ", ceiling(object.size(cache)/1e6)/1e3, "GB.\n", sep = "")

  class(cache) <- c("kalisCheckpointTable", class(cache))
  cache
}

#' Title
#'
#' Short description
#'
#' Detailed description
#'
#' @param fwd a forward table as returned by \code{\link{MakeForwardTable}}
#' @param cache a cache of forward tables as generated by
#'   \code{\link{CreateForwardTableCache}}
#' @param t a locus position to move the forward table to, using the cache for
#'   performance.  Must be greater than or equal to locus position of table
#'   provided in \code{fwd}.
#' @param Pi a matrix of background copying probabilities.  Can also provide a
#'   scalar value for uniform background copying probability.
#' @param mu a vector of ...
#' @param rho a vector of ...
#' @param nthreads the number of CPU cores on which to run
#'
#' @return There is nothing returned.  For performance reasons, the forward
#'   table which was passed in is updated in-place.
#'
#' @seealso \code{\link{MakeForwardTable}} to make a forward table;
#'
#'   \code{\link{CreateForwardTableCache}} to generate a cache;
#'
#'   \code{\link{Forward}} for forward function without using a cache.
#'
#' @examples
#' # Examples
ForwardUsingTableCache <- function(fwd, pars, cache, t = fwd$l+1, nthreads = 1) {
  if(!("kalisForwardTable" %in% class(fwd))) {
    stop("The fwd argument is not a valid forward table.")
  }
  if(!("kalisParameters" %in% class(pars))) {
    stop("The pars argument is not a valid parameters object.")
  }
  if(fwd$pars.sha256 != pars$sha256) {
    stop("The forward table provided was created with different parameter values (SHA-256 mismatch).")
  }
  if(!("kalisCheckpointTable" %in% class(cache))) {
    stop("The cache argument is not a valid forward table cache.")
  }
  if(cache[[1]]$pars.sha256 != pars$sha256) {
    stop("The forward table cache provided was created with different parameter values (SHA-256 mismatch).")
  }
  l <- sapply(cache, function(x) { x$l })
  if(any(l==t)) {
    CopyForwardTable(fwd, cache[[which(l==t)]])
    return()
  }
  todo <- which(l>t)
  l[todo] <- -1
  # Is the max -1?  Then we've passed the half way mark.  Fill up the first slot
  # and march on
  if(max(l) == -1) {
    ResetForwardTable(cache[[1]]) # Have to do this in C++ as must in place modify
    Forward(cache[[1]], pars, 1, nthreads)
    l[1] <- 1
    todo <- which(l==-1)
  }
  from <- max(l)
  from.idx <- which.max(l)

  # First, check if there are any spare slots -- we might just be accessing after
  # the last checkpoint already.  If so, run forward and return right away
  if(length(todo)==0) {
    CopyForwardTable(fwd, cache[[from.idx]])
    Forward(fwd, pars, t, nthreads)
    return()
  }

  # If we want just one step after the jumping off checkpoint, then we just wind
  # forward to it right away though I have spare checkpoint slots
  if(t == from+1) {
    CopyForwardTable(fwd, cache[[from.idx]])
    Forward(fwd, pars, t, nthreads)
    return()
  }

  # Now figure out how to fill in
  if(t-from <= length(todo)) {
    # In here, we have more spare slots than there are steps to reach t,
    # so do one step at a time and store into a cache element

    # NB t-from >= 2 due to if statement above
    for(i in 1:(t-from-1)) {
      CopyForwardTable(cache[[todo[i]]], cache[[from.idx]])
      Forward(cache[[todo[i]]], pars, from+i, nthreads)
      from.idx <- todo[i]
    }
    CopyForwardTable(fwd, cache[[from.idx]])
    Forward(fwd, pars, t, nthreads)
  } else {
    # We have more steps than spare slots, so we need a schedule to fill in the
    # gaps

    # NB t-from-1 >= 1 due to if statement above
    geom.spacing <- ceiling( (1-0.5^{1:length(todo)})*(t-from-1)+from )
    fillin <- rep(NA, length(geom.spacing))

    fillin[length(geom.spacing)] <- geom.spacing[length(geom.spacing)]
    if(length(geom.spacing)>1) {
      for(i in (length(geom.spacing)-1):1) {
        fillin[i] <- min(geom.spacing[i], fillin[i+1]-1)
      }
    }
    fillin <- unique(fillin[fillin>from & fillin<t])

    for(i in 1:length(fillin)) {
      CopyForwardTable(cache[[todo[i]]], cache[[from.idx]])
      Forward(cache[[todo[i]]], pars, fillin[i], nthreads)
      from.idx <- todo[i]
    }
    CopyForwardTable(fwd, cache[[from.idx]])
    Forward(fwd, pars, t, nthreads)
  }
}

print.kalisCheckpointTable <- function(x, ...) {
  if(class(x)!="kalisCheckpointTable")
    stop("Not a kalisCheckpointTable object")

  cat("Checkpoint Table object containing", length(x), "checkpoints.\n")
  cat("  Loci of checkpoints:\n")
  cat("   ", sapply(x, function(x) { x$l }), "\n")
  cat("  Memory consumed ≈", ceiling(object.size(x)/1e6)/1e3, "GB.\n")
}
